# âš™ï¸ ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„

> **ìì—°ì–´ ì²˜ë¦¬ Ã— Context-Aware Priority Ã— ë°©ì–´ì  ìŠ¤ì¼€ì¤„ë§**

---

## 1. ìì—°ì–´ ì…ë ¥ (NLP) íŒŒì‹± ë¡œì§

### 1.1 ì‹œìŠ¤í…œ ê°œìš”

ì‚¬ìš©ìê°€ "ë‚´ì¼ ì˜¤í›„ 3ì‹œì— íŒ€ ë¯¸íŒ…"ì²˜ëŸ¼ ìì—°ìŠ¤ëŸ½ê²Œ ì…ë ¥í•˜ë©´ ìë™ìœ¼ë¡œ êµ¬ì¡°í™”ëœ ë°ì´í„°ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

### 1.2 í•œêµ­ì–´ NLP íŒŒì„œ ì˜ì‚¬ì½”ë“œ

```python
def parse_natural_language_task(input_text: str) -> Task:
    """
    ìì—°ì–´ ì…ë ¥ì„ êµ¬ì¡°í™”ëœ Task ê°ì²´ë¡œ ë³€í™˜
    
    ì˜ˆì‹œ ì…ë ¥: "ë‚´ì¼ ì˜¤í›„ 3ì‹œì— íŒ€ ë¯¸íŒ… ê°•ë‚¨ì—­ì—ì„œ"
    ì˜ˆì‹œ ì¶œë ¥: Task(
        title="íŒ€ ë¯¸íŒ…",
        date=2026-01-19,
        time=15:00,
        location="ê°•ë‚¨ì—­",
        category="ë¯¸íŒ…"
    )
    """
    
    # 1ë‹¨ê³„: ì‹œê°„ í‘œí˜„ ì¶”ì¶œ
    time_patterns = {
        "ì˜¤ì „ (\d+)ì‹œ": lambda m: int(m.group(1)),
        "ì˜¤í›„ (\d+)ì‹œ": lambda m: int(m.group(1)) + 12,
        "(\d+)ì‹œ (\d+)ë¶„": lambda m: (int(m.group(1)), int(m.group(2))),
        "ì•„ì¹¨": 8,
        "ì ì‹¬": 12,
        "ì €ë…": 18,
        "ë°¤": 21
    }
    
    extracted_time = extract_time(input_text, time_patterns)
    
    # 2ë‹¨ê³„: ë‚ ì§œ í‘œí˜„ ì¶”ì¶œ
    date_patterns = {
        "ì˜¤ëŠ˜": get_today(),
        "ë‚´ì¼": get_today() + 1.day,
        "ëª¨ë ˆ": get_today() + 2.days,
        "ë‹¤ìŒì£¼ (ì›”|í™”|ìˆ˜|ëª©|ê¸ˆ|í† |ì¼)ìš”ì¼": calculate_next_weekday,
        "(\d+)ì›” (\d+)ì¼": lambda m: parse_date(m.group(1), m.group(2)),
        "ì´ë²ˆ ì£¼ë§": get_this_weekend()
    }
    
    extracted_date = extract_date(input_text, date_patterns)
    
    # 3ë‹¨ê³„: ì¥ì†Œ ì¶”ì¶œ (NER - Named Entity Recognition)
    location_keywords = ["ì—ì„œ", "ìœ¼ë¡œ", "ê¹Œì§€", "ì•ì—ì„œ"]
    extracted_location = extract_location(input_text, location_keywords)
    
    # 4ë‹¨ê³„: í”„ë¡œì íŠ¸/ì¹´í…Œê³ ë¦¬ ë¶„ë¥˜ (ML ê¸°ë°˜)
    categories = ["ì—…ë¬´", "ê³µë¶€", "ìš´ë™", "ì•½ì†", "ê°œì¸", "ì‡¼í•‘"]
    predicted_category = classify_category(input_text, categories)
    
    # 5ë‹¨ê³„: í•µì‹¬ ì œëª© ì¶”ì¶œ (ì‹œê°„/ì¥ì†Œ ì œì™¸í•œ í•µì‹¬ ë‚´ìš©)
    title = extract_core_title(
        input_text,
        remove=[extracted_time, extracted_date, extracted_location]
    )
    
    # 6ë‹¨ê³„: ìš°ì„ ìˆœìœ„ í‚¤ì›Œë“œ ë¶„ì„
    priority_indicators = {
        "urgent": ["ê¸‰í•œ", "ê¸´ê¸‰", "ì¤‘ìš”í•œ", "ê¼­", "ë°˜ë“œì‹œ"],
        "high": ["ì¤‘ìš”", "í•„ìˆ˜", "ë§ˆê°"],
        "medium": default,
        "low": ["ê°€ëŠ¥í•˜ë©´", "ì‹œê°„ë˜ë©´", "ë‚˜ì¤‘ì—"]
    }
    
    priority = detect_priority(input_text, priority_indicators)
    
    # 7ë‹¨ê³„: ì†Œìš” ì‹œê°„ ì¶”ì • (íˆìŠ¤í† ë¦¬ ê¸°ë°˜)
    estimated_duration = estimate_duration(
        category=predicted_category,
        title=title,
        user_history=get_user_task_history()
    )
    
    return Task(
        title=title,
        date=extracted_date,
        time=extracted_time,
        location=extracted_location,
        category=predicted_category,
        priority=priority,
        estimated_duration=estimated_duration,
        raw_input=input_text
    )
```

### 1.3 íŒŒì‹± ì˜ˆì‹œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

| ì…ë ¥ | ì¶”ì¶œ ê²°ê³¼ |
|------|----------|
| "ë‚´ì¼ ì˜¤í›„ 3ì‹œ íŒ€ ë¯¸íŒ…" | date: ë‚´ì¼, time: 15:00, title: íŒ€ ë¯¸íŒ…, category: ì—…ë¬´ |
| "ì´ë²ˆ ì£¼ ê¸ˆìš”ì¼ê¹Œì§€ ë ˆí¬íŠ¸ ì œì¶œ" | date: ê¸ˆìš”ì¼, deadline: true, title: ë ˆí¬íŠ¸ ì œì¶œ, priority: high |
| "ë§¤ì¼ ì•„ì¹¨ 7ì‹œ ì˜ì–´ ê³µë¶€ 30ë¶„" | recurring: daily, time: 07:00, title: ì˜ì–´ ê³µë¶€, duration: 30min |
| "ê¸‰í•œ! ì˜¤ëŠ˜ ì €ë… ì—„ë§ˆë‘ ì „í™”" | date: ì˜¤ëŠ˜, time: ì €ë…, priority: urgent, title: ì—„ë§ˆë‘ ì „í™” |

---

## 2. Context-Aware Priority ì•Œê³ ë¦¬ì¦˜

### 2.1 ê¸°ë³¸ ê³µì‹ (LaTeX)

ê¸°ì¡´ ìŠ¤ì¼€ì¤„ëŸ¬ë“¤ì˜ í•œê³„ë¥¼ ë„˜ì–´, **ì—ë„ˆì§€ ìˆ˜ì¤€**ê³¼ **ê³¼ê±° ì‘ì—… ì†ë„**ê¹Œì§€ ê³ ë ¤í•©ë‹ˆë‹¤.

$$
P_{final} = w_1 \cdot U + w_2 \cdot D + w_3 \cdot E + w_4 \cdot V + w_5 \cdot C
$$

**ë³€ìˆ˜ ì •ì˜:**

| ë³€ìˆ˜ | ì„¤ëª… | ë²”ìœ„ | ê°€ì¤‘ì¹˜ |
|------|------|------|--------|
| $U$ | Urgency (ê¸´ê¸‰ë„) | 0-1 | $w_1 = 0.30$ |
| $D$ | Deadline Proximity (ë§ˆê° ê·¼ì ‘ë„) | 0-1 | $w_2 = 0.25$ |
| $E$ | Energy Match (ì—ë„ˆì§€ ë§¤ì¹­) | 0-1 | $w_3 = 0.20$ |
| $V$ | Velocity Factor (ì‘ì—… ì†ë„) | 0-1 | $w_4 = 0.15$ |
| $C$ | Context Fit (ë§¥ë½ ì í•©ë„) | 0-1 | $w_5 = 0.10$ |

### 2.2 ê° ë³€ìˆ˜ ê³„ì‚°ì‹

**ê¸´ê¸‰ë„ (Urgency)**
$$
U = \begin{cases}
1.0 & \text{if user marked urgent} \\
0.8 & \text{if deadline today} \\
0.5 & \text{if deadline this week} \\
0.2 & \text{if deadline this month} \\
0.1 & \text{otherwise}
\end{cases}
$$

**ë§ˆê° ê·¼ì ‘ë„ (Deadline Proximity)**
$$
D = \max\left(0, 1 - \frac{\text{hours\_until\_deadline}}{168}\right)
$$

**ì—ë„ˆì§€ ë§¤ì¹­ (Energy Match)**
$$
E = 1 - |E_{required} - E_{current}|
$$

ì—¬ê¸°ì„œ:
- $E_{required}$: ì‘ì—…ì— í•„ìš”í•œ ì—ë„ˆì§€ ìˆ˜ì¤€ (0=ì €, 0.5=ì¤‘, 1=ê³ )
- $E_{current}$: í˜„ì¬ ì‹œê°„ëŒ€ì˜ ì˜ˆì¸¡ ì—ë„ˆì§€ ìˆ˜ì¤€

**ì‘ì—… ì†ë„ (Velocity Factor)**
$$
V = \frac{\text{avg\_completion\_time}}{\text{estimated\_time}}
$$

**ë§¥ë½ ì í•©ë„ (Context Fit)**
$$
C = \text{location\_match} + \text{time\_preference} + \text{tool\_availability}
$$

### 2.3 êµ¬í˜„ ì½”ë“œ

```javascript
class ContextAwarePriorityEngine {
  
  calculatePriority(task, userContext) {
    const weights = { u: 0.30, d: 0.25, e: 0.20, v: 0.15, c: 0.10 };
    
    const U = this.calculateUrgency(task);
    const D = this.calculateDeadlineProximity(task);
    const E = this.calculateEnergyMatch(task, userContext);
    const V = this.calculateVelocityFactor(task, userContext.history);
    const C = this.calculateContextFit(task, userContext);
    
    const finalPriority = 
      weights.u * U +
      weights.d * D +
      weights.e * E +
      weights.v * V +
      weights.c * C;
    
    return {
      score: finalPriority,
      breakdown: { U, D, E, V, C },
      recommendation: this.getRecommendation(finalPriority)
    };
  }
  
  calculateEnergyMatch(task, userContext) {
    // ì‹œê°„ëŒ€ë³„ ì—ë„ˆì§€ ì˜ˆì¸¡
    const hourlyEnergy = this.predictHourlyEnergy(userContext);
    const currentEnergy = hourlyEnergy[new Date().getHours()];
    const taskEnergy = this.getTaskEnergyRequirement(task.category);
    
    return 1 - Math.abs(taskEnergy - currentEnergy);
  }
  
  predictHourlyEnergy(userContext) {
    // ì‚¬ìš©ìì˜ ê³¼ê±° ì™„ë£Œ íŒ¨í„´ì—ì„œ í•™ìŠµ
    const completionByHour = userContext.history.completionPatterns;
    
    return Array.from({ length: 24 }, (_, hour) => {
      const baseEnergy = this.getCircadianRhythm(hour);
      const userPattern = completionByHour[hour] || 0.5;
      return (baseEnergy + userPattern) / 2;
    });
  }
  
  getCircadianRhythm(hour) {
    // ê¸°ë³¸ ìƒì²´ë¦¬ë“¬ ê³¡ì„ 
    const rhythmCurve = {
      5: 0.3, 6: 0.4, 7: 0.5, 8: 0.7, 9: 0.9, 10: 1.0,
      11: 0.95, 12: 0.6, 13: 0.5, 14: 0.55, 15: 0.7, 16: 0.8,
      17: 0.75, 18: 0.6, 19: 0.5, 20: 0.4, 21: 0.3, 22: 0.2
    };
    return rhythmCurve[hour] || 0.1;
  }
}
```

---

## 3. ë°©ì–´ì  ìŠ¤ì¼€ì¤„ë§ (Defensive Scheduling)

### 3.1 ê°œë…

ì¼ì •ì´ ê³¼ë„í•˜ê²Œ ì±„ì›Œì§€ëŠ” ê²ƒì„ ë°©ì§€í•˜ì—¬ ì‚¬ìš©ìì˜ **ì§‘ì¤‘ ì‹œê°„**ê³¼ **íœ´ì‹ ì‹œê°„**ì„ ë³´í˜¸í•©ë‹ˆë‹¤.

### 3.2 í•µì‹¬ ê·œì¹™

| ê·œì¹™ | ì„¤ëª… | ìë™ ì ìš© |
|------|------|----------|
| **80% ê·œì¹™** | í•˜ë£¨ì˜ 80%ë§Œ ìŠ¤ì¼€ì¤„, 20%ëŠ” ë²„í¼ | âœ… |
| **ë”¥ì›Œí¬ ë³´í˜¸** | ì˜¤ì „ 9-11ì‹œ ìë™ ì§‘ì¤‘ ì‹œê°„ | âœ… |
| **ì ì‹¬ ë³´í˜¸** | 12-13ì‹œ ìë™ íœ´ì‹ ì‹œê°„ | âœ… |
| **ì €ë… ë³´í˜¸** | 19ì‹œ ì´í›„ ê°€ë²¼ìš´ ì‘ì—…ë§Œ | âœ… |
| **ì—°ì† ì œí•œ** | 90ë¶„ ì´ìƒ ì—°ì† ì‘ì—… ì‹œ íœ´ì‹ ì•Œë¦¼ | âœ… |

### 3.3 ë°©ì–´ì  ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜

```javascript
class DefensiveScheduler {
  
  applyDefensiveRules(calendar, userPreferences) {
    const protectedSlots = [];
    
    // 1. ë”¥ì›Œí¬ ì‹œê°„ ë³´í˜¸
    protectedSlots.push(
      this.createProtectedSlot({
        label: "ğŸ¯ ì§‘ì¤‘ ì‹œê°„",
        start: userPreferences.deepWorkStart || "09:00",
        end: userPreferences.deepWorkEnd || "11:00",
        priority: "high",
        allowOverride: false
      })
    );
    
    // 2. ì ì‹¬ ì‹œê°„ ë³´í˜¸
    protectedSlots.push(
      this.createProtectedSlot({
        label: "ğŸ½ï¸ ì ì‹¬ ì‹œê°„",
        start: "12:00",
        end: "13:00",
        priority: "medium",
        allowOverride: true
      })
    );
    
    // 3. ì €ë… ê²½ê³„ ì„¤ì •
    protectedSlots.push(
      this.createSoftBoundary({
        label: "ğŸŒ™ ì €ë… ì‹œê°„",
        start: "19:00",
        restriction: "low_energy_tasks_only"
      })
    );
    
    // 4. 80% ê·œì¹™ ì ìš©
    const dailyCapacity = this.calculateDailyCapacity(calendar);
    const targetUtilization = 0.8;
    
    if (dailyCapacity.utilization > targetUtilization) {
      return {
        warning: "ì¼ì •ì´ ë„ˆë¬´ ë¹¡ë¹¡í•´ìš”! ğŸ¥º",
        suggestion: this.suggestRescheduling(calendar),
        autoDefend: this.autoCreateBuffers(calendar)
      };
    }
    
    return { calendar, protectedSlots };
  }
  
  autoCreateBuffers(calendar) {
    const busySlots = calendar.filter(slot => slot.type === 'task');
    const buffers = [];
    
    busySlots.forEach((slot, index) => {
      // 90ë¶„ ì´ìƒ ì—°ì† ì‘ì—… ì‹œ 15ë¶„ íœ´ì‹ ì‚½ì…
      if (slot.duration >= 90 && !this.hasBreakAfter(slot, busySlots[index + 1])) {
        buffers.push({
          type: 'break',
          label: 'â˜• ì ê¹ ì‰¬ì–´ê°€ê¸°',
          start: slot.end,
          duration: 15,
          autoGenerated: true
        });
      }
    });
    
    return buffers;
  }
  
  suggestRescheduling(calendar) {
    const overflowTasks = this.findOverflowTasks(calendar);
    
    return overflowTasks.map(task => ({
      task: task,
      alternatives: [
        { action: "ë‚´ì¼ë¡œ ì´ë™", confidence: 0.8 },
        { action: "ì‹œê°„ ë‹¨ì¶• (30ë¶„)", confidence: 0.6 },
        { action: "ìœ„ì„/ì·¨ì†Œ", confidence: 0.3 }
      ]
    }));
  }
}
```

### 3.4 ì‚¬ìš©ì í”¼ë“œë°± ë£¨í”„

```javascript
// ë°©ì–´ì  ìŠ¤ì¼€ì¤„ë§ í•™ìŠµ ì‹œìŠ¤í…œ
class SchedulingLearner {
  
  learnFromUserBehavior(events) {
    events.forEach(event => {
      switch(event.type) {
        case 'OVERRIDE_PROTECTION':
          // ì‚¬ìš©ìê°€ ë³´í˜¸ ì‹œê°„ì„ ë¬´ì‹œí•œ ê²½ìš°
          this.adjustProtectionPriority(event.slot, -0.1);
          break;
          
        case 'COMPLETED_IN_PROTECTED':
          // ë³´í˜¸ ì‹œê°„ì— ì‹¤ì œë¡œ ì§‘ì¤‘ ì‘ì—…ì„ ì™„ë£Œí•œ ê²½ìš°
          this.adjustProtectionPriority(event.slot, +0.2);
          break;
          
        case 'BURNOUT_SIGNAL':
          // ì‚¬ìš©ìê°€ í”¼ë¡œ ì‹ í˜¸ë¥¼ ë³´ì¸ ê²½ìš° (ë¯¸ì™„ë£Œ ê¸‰ì¦ ë“±)
          this.increaseBufferTime(0.1);
          break;
      }
    });
  }
}
```

---

## 4. ë°ì´í„° êµ¬ì¡°

### 4.1 Task ìŠ¤í‚¤ë§ˆ

```typescript
interface Task {
  id: string;
  title: string;
  description?: string;
  
  // ì‹œê°„ ê´€ë ¨
  scheduledDate?: Date;
  scheduledTime?: string;
  deadline?: Date;
  duration: number; // minutes
  isAllDay: boolean;
  
  // ë¶„ë¥˜
  category: 'work' | 'study' | 'exercise' | 'social' | 'personal' | 'shopping';
  project?: string;
  tags: string[];
  
  // ìš°ì„ ìˆœìœ„ & ìƒíƒœ
  priority: 'urgent' | 'high' | 'medium' | 'low';
  status: 'pending' | 'in_progress' | 'completed' | 'deferred' | 'cancelled';
  
  // AI ë©”íƒ€ë°ì´í„°
  energyRequired: number; // 0-1
  estimatedFocusLevel: 'deep' | 'medium' | 'shallow';
  aiSuggested: boolean;
  priorityScore: number; // calculated
  
  // ë°˜ë³µ
  recurrence?: {
    type: 'daily' | 'weekly' | 'monthly';
    interval: number;
    endDate?: Date;
    daysOfWeek?: number[];
  };
  
  // ë©”íƒ€
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
  rawInput?: string;
}
```

---

ë‹¤ìŒ: [04. ë¦¬í…ì…˜ ì „ëµ ë° í–‰ë™ ì„¤ê³„](./04_ë¦¬í…ì…˜_ì „ëµ_í–‰ë™_ì„¤ê³„.md)
